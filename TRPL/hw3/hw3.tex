 \documentclass[12pt]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}        % Кодировка входного документа;
                                    % при необходимости, вместо cp1251
                                    % можно указать cp866 (Alt-кодировка
                                    % DOS) или koi8-r.

\usepackage[english,russian]{babel} % Включение русификации, русских и
                                    % английских стилей и переносов
%%\usepackage{a4}
%%\usepackage{moreverb}
\usepackage{amsmath,amsfonts,amsthm,amssymb,amsbsy,amstext,amscd,amsxtra,multicol}
\usepackage{verbatim}
\usepackage{tikz} %Рисование автоматов
\usetikzlibrary{automata,positioning}
\usepackage{multicol} %Несколько колонок
\usepackage{graphicx}
\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage[stable]{footmisc}

%% \voffset-5mm
%% \def\baselinestretch{1.44}
\renewcommand{\theequation}{\arabic{equation}}
\def\hm#1{#1\nobreak\discretionary{}{\hbox{$#1$}}{}}
\newtheorem{Lemma}{Лемма}
\theoremstyle{definiton}
\newtheorem{Remark}{Замечание}
%%\newtheorem{Def}{Определение}
\newtheorem{Claim}{Утверждение}
\newtheorem{Cor}{Следствие}
\newtheorem{Theorem}{Теорема}
\theoremstyle{definition}
\newtheorem{Example}{Пример}
\newtheorem*{known}{Теорема}
\def\proofname{Доказательство}
\theoremstyle{definition}
\newtheorem{Def}{Определение}

%% \newenvironment{Example} % имя окружения
%% {\par\noindent{\bf Пример.}} % команды для \begin
%% {\hfill$\scriptstyle\qed$} % команды для \end






%\date{22 июня 2011 г.}
\let\leq\leqslant
\let\geq\geqslant
\def\MT{\mathrm{MT}}
%Обозначения ``ажуром''
\def\BB{\mathbb B}
\def\CC{\mathbb C}
\def\RR{\mathbb R}
\def\SS{\mathbb S}
\def\ZZ{\mathbb Z}
\def\NN{\mathbb N}
\def\FF{\mathbb F}
%греческие буквы
\let\epsilon\varepsilon
\let\es\emptyset
\let\eps\varepsilon
\let\al\alpha
\let\sg\sigma
\let\ga\gamma
\let\ph\varphi
\let\om\omega
\let\ld\lambda
\let\Ld\Lambda
\let\vk\varkappa
\let\Om\Omega
\def\abstractname{}

\def\R{{\cal R}}
\def\A{{\cal A}}
\def\B{{\cal B}}
\def\C{{\cal C}}
\def\D{{\cal D}}
\let\w\omega

%классы сложности
\def\REG{{\mathsf{REG}}}
\def\CFL{{\mathsf{CFL}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Problems macros  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{xparse}
\usepackage{ifthen}
\usepackage{bm} %%% bf in math mode
\usepackage{color}
%\usepackage[usenames,dvipsnames]{xcolor}

\definecolor{Gray555}{HTML}{555555}
\definecolor{Gray444}{HTML}{444444}


\newcounter{problem}
\newcounter{uproblem}
\newcounter{subproblem}
\newcounter{prvar}


\def\pr{\medskip\noindent\stepcounter{problem}{\bf \theproblem .  }\setcounter{subproblem}{0} }
\def\prstar{\medskip\noindent\stepcounter{problem}{\bf $\mathbf{\theproblem}^*$\negthickspace.  }\setcounter{subproblem}{0} }
\def\prpfrom[#1]{\medskip\noindent\stepcounter{problem}{\bf Задача \theproblem~(№#1 из задания).  }\setcounter{subproblem}{0} }
\def\prp{\medskip\noindent\stepcounter{problem}{\bf Задача \theproblem .  }\setcounter{subproblem}{0} }

\def\prpvar{\medskip\noindent\stepcounter{problem}\setcounter{prvar}{1}{\bf Задача \theproblem \;({\rm\Rnum{\theprvar}}).  }\setcounter{subproblem}{0} }
\def\prpv{\medskip\noindent\stepcounter{prvar}{\bf Задача \theproblem \,$\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$.  }\setcounter{subproblem}{0} }
\def\prv{\medskip\noindent\stepcounter{prvar}{\bf \theproblem\,$\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$}. \setcounter{subproblem}{0} }

\def\prpstar{\medskip\noindent\stepcounter{problem}{\bf Задача $\bf\theproblem^*$\negthickspace.  }\setcounter{subproblem}{0} }
\def\prdag{\medskip\noindent\stepcounter{problem}{\bf Задача $\theproblem^{^\dagger}$\negthickspace\,.  }\setcounter{subproblem}{0} }
\def\upr{\medskip\noindent\stepcounter{uproblem}{\bf Упражнение \theuproblem .  }\setcounter{subproblem}{0} }
%\def\prp{\vspace{5pt}\stepcounter{problem}{\bf Задача \theproblem .  } }
%\def\prs{\vspace{5pt}\stepcounter{problem}{\bf \theproblem .*   }
\def\prsub{\medskip\noindent\stepcounter{subproblem}{\sf \thesubproblem .} }
\def\prsubr{\medskip\noindent\stepcounter{subproblem}{\sf \thesubproblem)} }
\def\prsubstar{\medskip\noindent\stepcounter{subproblem}{$\mathsf{\thesubproblem^*}$\negthickspace.  } }
\def\prsubrstar{\medskip\noindent\stepcounter{subproblem}{\sf $\mathsf{\thesubproblem^*}$)  } }

\newcommand{\bracketspace}[1]{\phantom{(}\!\!{#1}\!\!\phantom{)}}

\DeclareDocumentCommand{\Prpvar}{ O{null} O{} }{
	\medskip\noindent\stepcounter{problem}\setcounter{prvar}{1}{\bf Задача \theproblem 
% 	\ifthenelse{\equal{#1}{null}}{  }{ {\sf $\bm\langle$\bracketspace{#1}$\bm\rangle$}}
%	~\!\!(\bracketspace{{\rm\Rnum{\theprvar}}}).  }\setcounter{subproblem}{0} 
%	\;(\bracketspace{{\rm\Rnum{\theprvar}}})}\setcounter{subproblem}{0} 
%
	\,{\sf $\bm\langle$\bracketspace{{\rm\Rnum{\theprvar}}}$\bm\rangle$}
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}}.

}
%\DeclareDocumentCommand{\Prpvar}{ O{level} O{meta} m }{\prpvar}


\DeclareDocumentCommand{\Prp}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\medskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача \theproblem 
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.
}
%\DeclareDocumentCommand{\Prp}{ O{level} O{meta} }

\DeclareDocumentCommand{\Prps}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\medskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача $\bm\theproblem^* $
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.
}

\DeclareDocumentCommand{\Prpd}{ O{null} O{null} }{\setcounter{subproblem}{0}
	\medskip\noindent\stepcounter{problem}\setcounter{prvar}{0}{\bf Задача $\bm\theproblem^\dagger$ 
	~\!\!\! \ifthenelse{\equal{#1}{null}}{\!}{{\sf(\bracketspace{#1})}}
	 \ifthenelse{\equal{#2}{null}}{\!}{{\sf [\color{Gray444}\,\bracketspace{{\fontfamily{afd}\selectfont#2}}\,]}}}.
}


\def\prend{
%	\bigskip
	\bigskip
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Eof Problems macros  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%прочее
\def\quotient{\backslash\negthickspace\sim}
\begin{document}
	\centerline{\LARGE Задание 3}

	\medskip

%	\centerline{\Large НКА и ДКА;\\ Лемма о накачке;\\ Автоматы и распознавание текстов. }

\begin{center}
	{\Large НКА и ДКА
	
		Лемма о накачке 
		
		\vspace{0.5ex}
		
		Автоматы и распознавание текстов
		
		\vspace{0.5ex}
		
		Усвяцов Михаил Рудольфович, 176 б}
\end{center}

	\bigskip

	\prp Определим язык $L_i = \{w\,|\, |w|= n, w[n-i] = 1 \}$, то есть в язык $L_i$ входят все слова, в которых $1$ стоит на $i$-ом месте от конца\footnote{Во избежании путаницы, первый с конца символ -- это последний символ слова.}. Постройте НКА, распознающий язык $L_3$. По построенному НКА постройте ДКА.
	
	Построение НКА для заданного языка не вызывает трудностей.
	
	\begin{center}
		\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
			\node[state,initial]		 	(q_0)	{$q_0$};
			\node [state] 					(q_1) [right = of q_0]	{$q_1$};
			\node [state] 					(q_2) [right = of q_1]	{$q_2$};		
			\node [state] 					(q_3) [right = of q_2]	{$q_3$};
			\node [state, accepting] 					(q_4) [right = of q_3]	{$q_4$};
			\path[->] 
			(q_0)	edge	[loop]	node	{$0,1$}	()
			edge	 	node	{$0,1$}	(q_1)
			(q_1)	edge		node	{$1$} (q_2)
			(q_2)	edge		node    {$0,1 $} (q_3)
			(q_3)	edge		node    {$0,1$} (q_4);
		\end{tikzpicture}
	\end{center}
	
	Для построения ДКА будем придерживаться алгоритма из книги Серебрякова.
	\begin{enumerate}
		\item Так как из $q_0$ нет $\epsilon$ переходов, то помечаем $q_0$ как непомеченное.
		\item move($q_0$, 0) = \{$q_0, q_1$\}.
		\item Ставим множество \{$q_0, q_1$\} в очередь непемеченных.
		\item move($q_0$, 1) = \{$q_0, q_1$\}.
		\item move($(q_0, q_1)$, 0) = \{$q_0, q_1$\}.
		\item move($(q_0, q_1)$, 1) = \{$q_0, q_1, q_2$\}.
		\item Ставим множество \{$q_0, q_1, q_2$\} в очередь непемеченных.
		\item move($(q_0, q_1, q_2)$, 0) = \{$q_0, q_1, q_3$\}.
		\item Ставим множество \{$q_0, q_1, q_3$\} в очередь непемеченных.
		\item move($(q_0, q_1, q_2)$, 1) = \{$q_0, q_1, q_2, q_3$\}.
		\item Ставим множество \{$q_0, q_1, q_2, q_3$\} в очередь непемеченных.
		\item move($(q_0, q_1, q_3)$, 0) = \{$q_0, q_1, q_4$\}.
		\item Ставим множество \{$q_0, q_1, q_4$\} в очередь непемеченных.
		\item move($(q_0, q_1, q_3)$, 1) = \{$q_0, q_1, q_2, q_4$\}.
		\item Ставим множество \{$q_0, q_1, q_2, q_4$\} в очередь непемеченных.
		\item move($q_0, q_1, q_2, q_3$, 0) = \{$q_0, q_1, q_3, q_4$\}.
		\item Ставим множество \{$q_0, q_1, q_3, q_4$\} в очередь непемеченных.
		\item move($(q_0, q_1, q_2, q_3)$, 1) = \{$q_0, q_1, q_2, q_3, q_4$\}.
		\item Ставим множество \{$q_0, q_1, q_2, q_3, q_4$\} в очередь непемеченных.
		\item move($(q_0, q_1, q_4)$, 0) = \{$q_0, q_1$\}.
		\item move($(q_0, q_1, q_4)$, 1) = \{$q_0, q_1, q_2$\}.
		\item move($(q_0, q_1, q_2, q_4)$, 0) = \{$q_0, q_1, q_3$\}.
		\item move($(q_0, q_1, q_2, q_4)$, 1) = \{$q_0, q_1, q_2, q_3$\}.
		\item move($(q_0, q_1, q_3, q_4)$, 0) = \{$q_0, q_1, q_4$\}.
		\item move($(q_0, q_1, q_3, q_4)$, 1) = \{$q_0, q_1, q_2, q_4$\}.
		\item move($(q_0, q_1, q_2, q_3, q_4)$, 0) = \{$q_0, q_1, q_3, q_4$\}.
		\item move($(q_0, q_1, q_2, q_3, q_4)$, 1) = \{$q_0, q_1, q_2, q_3, q_4$\}.
	\end{enumerate}
	
	Теперь, когда мы описали все функции переходов, изобразим полученный ДКА.

	\begin{center}
		\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
			\node[state,initial] (q_0) {$q_0$};
			\node [state] (q_01) [right = of q_0] {$q_0q_1$};
			\node [state] (q_012) [above right = of q_01] {$q_0q_1q_2$};
			\node [state] (q_013) [below right = of q_01] {$q_0q_1q_3$};
			\node [state] (q_0123) [above right = of q_012] {$q_0q_1q_2q_3$};
			\node [state, accepting] (q_014) [below right = of q_013] {$q_0q_1q_4$};
			\node [state, accepting] (q_0124) [above right = of q_013] {$q_0q_1q_2q_4$};
			\node [state, accepting] (q_0134) [above right = of q_0123] {$q_0q_1q_3q_4$};
			\node [state, accepting] (q_01234) [below right = of q_0123] {$q_0q_1q_2q_3q_4$};
			\path[->] 
			(q_0) edge node	{$0,1$}	(q_01)
			(q_01) edge [loop above] node {$0$} ()
					   edge node {$1$} (q_012)
			(q_012)	edge node {$0$} (q_013)
						 edge node {$1$} (q_0123)
			(q_013)	edge node {$0$} (q_014)
						 edge node {$1$} (q_0124)
			(q_0123) edge node {$0$} (q_0134)
						   edge [bend left] node {$1$} (q_01234)
			(q_014) edge [bend left] node {$0$} (q_01)
						 edge [bend right] node {$1$} (q_012)
			(q_0124) edge [bend left] node {$0$} (q_013)
						   edge node {$1$} (q_0123)
			(q_0134) edge [bend left] node {$0$} (q_014)
						   edge node {$1$} (q_0124)
			(q_01234) edge node {$0$} (q_0134)
							 edge [loop below] node {$1$} ();
		\end{tikzpicture}
	\end{center}

	\prpstar Докажите, что на языках $L_i$ между НКА и построенными по ним ДКА достигается экспоненциальный разрыв.	

	Исходя из постановки задачи, языку принадлежат все слова, у которых на месте i с конца стоит 1. При этом значения в остальных позициях значения не имеют. Тогда понятно, что ДКА, эквивалентный этому языку должен помнить все последние i символов. Всего имеется  $2^i$ последовательностей, состоящих из из последних i символов. Таким образом, Если в ДКА меньше $2^i$ состояний, то нашлось бы такое состояние q, что автомат попадает в него при прочтении двух разных последовательностей a и b. Рассмотрим такие последовательности a и b, что $a_i \neq  b_i$. Теперь очевидно, что какое бы мы не задали i, автомат обязан иметь состояние, которое одновременно будет приемным и неприниемным, так как через одино и то же состояние q будет проходить цепочка удовлетворяющее языку и цепочка ему неудовлетворяющие. Из этого противоречия можно заключить, что число состояний ДКА должно быть $2^i$. ЧТД.

\prp Будут ли регулярными следующие языки?

\medskip

 \prsub  $L = \{ a^{2013n+5}\mid n=0,1, \} \cap \{ a^{503k+29}\mid k=401,402,\ldots \}  \subseteq  \{ a^* \}$.
 
 Да, регулярен. Я нашел общее решение диафантового уравнения $a^{2013n + 5} = a^{503k +29}$. При заданных n и k решений этого уравнения не существует, следовательно, пересечение первых двух множеств пусто. Пустое множество регулярно по определению регулярного языка.

\medskip

 \prsub  $L_2 = \{ a^{200n^2+1}\mid n=1000,1001,\ldots \}  \subseteq  \{ a^* \}$.
 
 Применим лемму о накачке.
 
 Разобьем наш язык на xyz так, что $y = a^k, k \geq 1$. Тогда любое слово нашего языка можно будет записать как: $a^{200n^2+1 - k - m}a^ka^m$. А теперь прокачем y: $a^{200n^2+1 - k - m}a^{2k}a^m$ уже не принадлежит нашему языку. Значит, язык нерегулярен.

\medskip


\prsub  Язык $L_3$ всех слов в алфавите  $\{ 0, 1 \}$, которые представляют числа в двоичной записи, дающие остаток два при делении на три (слово читается со старших разрядов). Например, $001010\, (1010_2=10_{10} = 3 \times 3+1)  \not\in  L_3$,
а $10001\, (10001_{2}=17_{10} = 5 \times  3+2)  \in  L_3 $.

Воспользуемся отрицанием леммы о накачке. Рассмотрим слово 101. Пусть y = 0. Но 1001 уже не принадлежит языку $L_3$. Следовательно, язык нерегулярен.

\prp Постройте по НКА $\A$ ДКА $\B$.

\begin{center}
	\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
	%\draw[help lines] (0,0) grid (3,2);
	\node	(A) {\large \quad$\A:$};
	\node[state,initial]		 	(q_0) [right = of A]	{$q_0$};
	\node [state] 					(q_1) [right = of q_0]	{$q_1$};
	\node [state] 					(q_2) [right = of q_1]	{$q_2$};		
	\node [state] 					(q_3) [right = of q_2]	{$q_3$};
	\node [state, accepting] 					(q_4) [right = of q_3]	{$q_4$};
	\path[->] 
	(q_0)	edge	[loop]	node	{$a,b$}	()
	edge	 	node	{$a$}	(q_1)
	(q_1)	edge		node	{$b$} (q_2)
	(q_2)	edge		node    {$a $} (q_3)
	(q_3)	edge		node    {$a $} (q_4)
	(q_4)   edge [loop]	node	{$a,b$} ();
	\end{tikzpicture}
\end{center}
\medskip

\begin{center}
	\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
	%\draw[help lines] (0,0) grid (3,2);
	\node	(A) {\large \quad$ДКА \B:$};
	\node[state,initial]		 	(q_0) [right = of A]	{$q_0$};
	\node[state,initial]		 	(q_0p) [right = of q_0]	{$q^\prime_0$};
	\node [state] 					(q_1) [right = of q_0p]	{$q_1$};
	\node [state] 					(q_2) [right = of q_1]	{$q_2$};		
	\node [state, accepting] (q_3) [right = of q_2]	{$q_3$};
	\path[->] 
	(q_0)	edge	[loop]	node	{$b$}	()
	edge	 	node	{$a$}	(q_0p)
	(q_0p) edge [loop] node {$a$} ()
	edge node {$b$} (q_1)
	(q_1)	edge		node	{$a$} (q_2)
	(q_2)	edge		node    {$a $} (q_3)
	(q_3)   edge [loop]	node	{$a,b$} ();
	\end{tikzpicture}
\end{center}

\medskip
	\prpstar Докажите, что в ДКА, распознающем язык $\Sigma^*w\Sigma^*$ не может быть меньше состояний чем элементов последовательности $l(w), l(l(w)),\ldots$
	
	Для начала выбросим из рассмотрения $\Sigma^*$, так как мы рассматриваем минимальное возможное количество состояний. Теперь осталось доказать, что ДКА, который распознает w не может иметь меньше состояний, чем элементов в последовательности $l(w), l(l(w)),\ldots$.
	
	Рассмотрим строку w = a. Для разбора такой строки необходимо 2 состояние ДКА. l(a) = $\epsilon$.  Следовательно, условия задачи выполняются. Теперь предположим, что для строки $w \in {a|b}^*$ длины n условия задачи выполняется, то есть для разбора строки w ДКА необходимо больше или равно состояний, чем в последовательности собственных префиксов слова w. Теперь рассмотрим случай с добавлением нового сивола в конец или начало слова. Приписывание справа буквы а могло увеличить количество префиксов. Тогда рассмотрим, сколько максимально могло бы быть собственных префиксов у нового слова, исходя из его длины. $(a^n) = a^{n-1}$. Следовательно, для слова длиной n + 1 максимально возможное число элементов в последовательности собственных префиксов не превышает n + 1. ДКА для разбора нового слова так же должен иметь n + 2 состояний. ЧТД.
\bigskip

\prp Постройте КМП-автомат для слова $abaa$.

\begin{center}
	\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
		\node[state, initial] (epsilon) {$\epsilon$};
		\node[state] (a) [right = of epsilon] {$a$};
		\node[state] (ab) [right = of a] {$ab$};
		\node [state] (aba) [right = of ab]	{$aba$};
		\node [state, accepting] (abaa) [right = of aba] {$abaa$};
		\path[->]
		(epsilon) edge node {$a$} (a)
					  edge [loop] node {$b$} ()
		(a) edge [loop] node {$a$} ()
			 edge node {$b$} (ab)
		(ab) edge [bend left] node {$a$} (aba)
			   edge [bend left] node {$b$} (epsilon)
		(aba) edge node {$a$} (abaa)
                edge [bend left] node {$b$} (ab)
        (abaa) edge [loop] node {$a,b$} ()  
		;
	\end{tikzpicture}
\end{center}
	
\prpstar Докажите, что КМП-автомат для слова $w$ распознаёт язык $\Sigma^*w\Sigma^*$.


		\section{Дополнительные задачи}	

		\prp Приведите протокол работы КМП-алгоритма при поиске подслова $abba$ в слове $abbbababbab$.
		
		Начнем разбирать строчку  $abbaTabbbababbab$
		
		\begin{enumerate}
			\item l[1] = l("a").length = 0
			\item l[2] = l("ab").length = 0
			\item l[3] = l("abb").length = 0
			\item l[4] = l("abba").length = 0
			\item l[5] = l("abbaT").length = 0
			\item l[6] = l("abbaTa").length = 1
			\item l[7] = l("abbaTab").length = 2
			\item l[8] = l("abbaTabb").length = 3
			\item l[9] = l("abbaTabbb").length = 0
			\item l[10] = l("abbaTabbba").length = 1
			\item l[11] = l("abbaTabbbab").length = 2
			\item l[12] = l("abbaTabbbaba").length = 1
			\item l[13] = l("abbaTabbbabab").length = 2
			\item l[14] = l("abbaTabbbababb").length = 3
			\item l[15] = l("abbaTabbbababba").length = 4
			\item l[16] = l("abbaTabbbababbab").length = 2
			\item Мы можем сказать, что подтсрока входит в строку  тогда и только тогда, когда в массиве l есть число равное длине подстроки. Длина подстроки - 4. Следовательно, она найдена
		\end{enumerate}

\end{document}